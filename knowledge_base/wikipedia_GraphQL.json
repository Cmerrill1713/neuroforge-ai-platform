{
  "id": "wikipedia_GraphQL",
  "title": "GraphQL",
  "url": "https://en.wikipedia.org/wiki/GraphQL",
  "content": "GraphQL is a data query and manipulation language that allows specifying what data is to be retrieved (\"declarative data fetching\") or modified. A GraphQL server can process a client query using data from separate sources and present the results in a unified graph.[2] The language is not tied to any specific database or storage engine. There are several open-source runtime engines for GraphQL.\n\nFacebook started GraphQL development in 2012 and released a draft specification and reference implementation as open source in 2015.[3] In 2018, GraphQL was moved to the newly established GraphQL Foundation, hosted by the non-profit Linux Foundation.[4][5]\n\nOn February 9, 2018, the GraphQL Schema Definition Language became part of the specification.[6]\n\nMany popular public APIs adopted GraphQL as the default way to access them. These include public APIs of Facebook, GitHub, Yelp, Shopify, Google Directions API and many others.[7][8]\n\nGraphQL supports reading, writing (mutating), and subscribing to changes to data (realtime updates – commonly implemented using WebSockets).[9] A GraphQL service is created by defining types with fields, then providing functions to resolve the data for each field. The types and fields make up what is known as the schema definition. The functions that retrieve and map the data are called resolvers.[10]\n\nAfter being validated against the schema, a GraphQL query is executed by the server. The server returns a result that mirrors the shape of the original query, typically as JSON.[11]\n\nWith GraphQL, you model your business domain as a graph by defining a schema; within your schema, you define different types of nodes and how they connect/relate to one another.[12]\n\nThe GraphQL type system describes what data can be queried from the API. The collection of those capabilities is referred to as the service’s schema and clients can use that schema to send queries to the API that return predictable results.[13]\n\nThe root type of a GraphQL schema, Query by default, contains all of the fields that can be queried. Other types define the objects and fields that the GraphQL server can return. There are several base types, called scalars, to represent things like strings, numbers, and IDs.\n\nFields are defined as nullable by default, and a trailing exclamation mark can be used to make a field non-nullable (required). A field can be defined as a list by wrapping the field's type in square brackets (for example, authors: [String]).[14]\n\nA GraphQL query defines the exact shape of the data needed by the client.\n\nOnce validated and executed by the GraphQL server, the data is returned in the same shape.\n\nA GraphQL mutation allows for data to be created, updated, or deleted. Mutations generally contain variables, which allow data to be passed into the server from the client. The mutation also defines the shape of the data that will be returned to the client after the operation is complete.\n\nThe variables are passed as an object with fields that match the variable names in the mutation.\n\nOnce the operation is complete, the GraphQL server will return data matching the shape defined by the mutation.\n\nGraphQL also supports live updates sent from the server to client in an operation called a subscription. Again, the client defines the shape of the data that it needs whenever an update is made.\n\nWhen a mutation is made through the GraphQL server that updates the associated field, data is sent to all subscribed clients in the format setup through the subscription.\n\nWhile there’s nothing that prevents a GraphQL service from being versioned just like any other API, GraphQL takes a strong opinion on avoiding versioning by providing the tools for the continuous evolution of a GraphQL schema.[15]\n\nThe @deprecated built-in directive is used within the type system definition language to indicate deprecated portions of a GraphQL service’s schema, such as deprecated fields on a type or deprecated enum values.[14]\n\nGraphQL only returns the data that’s explicitly requested, so new capabilities can be added via new types or new fields on existing types without creating a breaking change. This has led to a common practice of always avoiding breaking changes and serving a versionless API.[15]\n\nGraphQL does not provide a full-fledged graph query language such as SPARQL, or even in dialects of SQL that support transitive closure.  For example, a GraphQL interface that reports the parents of an individual cannot return, in a single query, the set of all their ancestors.\n\nGraphQL APIs can be tested manually or with automated tools issuing GraphQL requests and verifying the correctness of the results. Automatic test generation is also possible.[16] New requests may be produced through search-based techniques due to a typed schema and introspection capabilities.[17]\n\nSome of the software tools used for testing GraphQL implementations include Postman, GraphiQL, Apollo Studio, GraphQL Hive, GraphQL Editor, and Step CI.[18]",
  "source_type": "wikipedia_article",
  "domain": "general_knowledge",
  "keywords": [
    "wikipedia",
    "ai",
    "programming",
    "technology",
    "graphql"
  ],
  "retrieval_tags": [
    "wikipedia",
    "article",
    "ai",
    "programming",
    "knowledge"
  ]
}