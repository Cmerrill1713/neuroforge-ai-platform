{
  "id": "meta_github_54922422",
  "title": "pysparnn",
  "description": "Approximate Nearest Neighbor Search for Sparse Data in Python!",
  "url": "https://github.com/facebookresearch/pysparnn",
  "language": "Python",
  "stars": 920,
  "forks": 145,
  "created_at": "2016-03-28T20:43:42Z",
  "updated_at": "2025-09-23T19:04:51Z",
  "topics": [],
  "readme_content": "# PySparNN\nApproximate Nearest Neighbor Search for Sparse Data in Python! This library is well suited to finding nearest neighbors in sparse, high dimensional spaces (like text documents). \n\nOut of the box, PySparNN supports Cosine Distance (i.e. 1 - cosine_similarity).\n\nPySparNN benefits:\n * Designed to be efficient on sparse data (memory & cpu).\n * Implemented leveraging existing python libraries (scipy & numpy).\n * Easily extended with other metrics: Manhattan, Euclidian, Jaccard, etc.\n * Supports incremental insertion of elements.\n\nIf your data is NOT SPARSE - please consider [faiss](https://github.com/facebookresearch/faiss) or [annoy](https://github.com/spotify/annoy). They use similar methods and I am a big fan of both. You should expect better performance on dense vectors from both of those projects.\n\nThe most comparable library to PySparNN is scikit-learn's LSHForest module. As of this writing, PySparNN is ~4x faster on the 20newsgroups dataset (as a sparse vector). A more robust benchmarking on sparse data is desired. [Here is the comparison.](https://github.com/facebookresearch/pysparnn/blob/master/examples/sparse_search_comparison.ipynb) [Here is another comparison](https://github.com/facebookresearch/pysparnn/blob/master/examples/enron.ipynb) on the larger Enron email dataset.\n\n\n## Example Usage\n### Simple Example\n```python\nimport pysparnn.cluster_index as ci\n\nimport numpy as np\nfrom scipy.sparse import csr_matrix\n\nfeatures = np.random.binomial(1, 0.01, size=(1000, 20000))\nfeatures = csr_matrix(features)\n\n# build the search index!\ndata_to_return = range(1000)\ncp = ci.MultiClusterIndex(features, data_to_return)\n\ncp.search(features[:5], k=1, return_distance=False)\n>> [[0], [1], [2], [3], [4]]\n```\n### Text Example\n```python\nimport pysparnn.cluster_index as ci\n\nfrom sklearn.feature_extraction.text import TfidfVectorizer\n\ndata = [\n    'hello world',\n    'oh hello there',\n    'Play it',\n    'Play it again Sam',\n]    \n\ntv = TfidfVectorizer()\ntv.fit(data)\n\nfeatures_vec = tv.transform(data)\n\n# build the search index!\ncp = ci.MultiClusterIndex(features_vec, data)\n\n# search the index with a sparse matrix\nsearch_data = [\n    'oh there',\n    'Play it again Frank'\n]\n\nsearch_features_vec = tv.transform(search_data)\n\ncp.search(search_features_vec, k=1, k_clusters=2, return_distance=False)\n>> [['oh hello there'], ['Play it again Sam']]\n\n```\n\n## Requirements\nPySparNN requires numpy and scipy. Tested with numpy 1.11.2 and scipy 0.18.1.\n\n## Installation\n```bash\n# clone pysparnn\ncd pysparnn \npip install -r requirements.txt \npython setup.py install\n```\n\n## How PySparNN works\nSearching for a document in an collection of D documents is naively O(D) (assuming documents are constant sized). \n\nHowever! we can create a tree structure where the first level is O(sqrt(D)) and each of the leaves are also O(sqrt(D)) - on average.\n\nWe randomly pick sqrt(D) candidate items to be in the top level. Then -- each document in the full list of D documents is assigned to the closest candidate in the top level.\n\nThis breaks up one O(D) search into two O(sqrt(D)) searches which is much much faster when D is big!\n\nThis generalizes to h levels. The runtime becomes:\n    O(h * h_root(D))\n\n## Further Information\nhttp://nlp.stanford.edu/IR-book/html/htmledition/cluster-pruning-1.html\n\nSee the CONTRIBUTING file for how to help out.\n\n## License\nPySparNN is BSD-licensed. We also provide an additional patent grant.\n",
  "source_type": "meta_github_repository",
  "domain": "meta_ai",
  "keywords": [],
  "retrieval_tags": [
    "meta",
    "ai",
    "github",
    "repository",
    "research"
  ]
}