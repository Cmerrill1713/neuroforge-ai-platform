{
  "id": "meta_github_35127847",
  "title": "CParser",
  "description": "A compact C preprocessor and declaration parser written in pure Lua",
  "url": "https://github.com/facebookresearch/CParser",
  "language": "Lua",
  "stars": 212,
  "forks": 21,
  "created_at": "2015-05-05T22:51:29Z",
  "updated_at": "2025-09-24T11:20:18Z",
  "topics": [],
  "readme_content": "# CParser\n\nThis pure Lua module implements (1) a standard compliant C\npreprocessor with a couple useful extensions, and (2) a parser that\nprovides a Lua friendly description of all global declarations and\ndefinitions in a C header or C program file.\n\nThe driver program `lcpp` invokes the preprocessor and outputs\npreprocessed code. Although it can be used as a replacement for the\nnormal preprocessor, it is more useful as an extra preprocessing step\n(see option `-Zpass` which is on by default.)  The same capabilities\nare offered by functions `cparser.cpp` and `cparser.cppTokenIterator`\nprovided by the module `cparser`.\n\nThe driver program `lcdecl` analyzes a C header file and a C program\nfile and outputs a short descriptions of the declarations and\ndefinitions. This program is mostly useful to understand the\nrepresentations produced by the `cparser` function\n`cparser.declarationIterator`.\n\nThis code is licensed under the MIT license found in\nthe LICENSE file in the root directory of this source tree.\n\n---\n\n## Program `lcpp`\n\n### Synopsis\n\n```sh\n    lcpp [options] inputfile.c [-o outputfile.c]\n```\nPreprocess file `inputfile.c` and write the preprocessed code into\nfile `outputfile.c` or to the standard output.\n\n### Options\n\nThe following options are recognized:\n\n- `-Werror`  \n  Cause all warning to be treated as errors.\n  Note that parsing cannot resume after an error.\n  The parser simply throws a Lua error.\n\n- `-w`   \n  Do not print warning messages.\n\n- `-D`*sym*`[=`*val*`]`  \n   Define preprocessor symbol `sym` to value `val`.\n   The default value of `val` is `1`.\n   Note that it is possible to define function-like symbols\n   with syntax `-Dsym(args)=val`.\n\n- `-U`*sym*   \n  Undefine preprocessor symbol `sym`.\n\n- `-I`*dir*   \n  Add directory `dir` to the search path for included files. Note\n  that there is no default search path. When an include file is not\n  found the include directive is simply ignored with a warning (but\n  see also option `-Zpass`).  Therefore all include directives are\n  ignored unless one uses option `-I` to specify the search path.\n\n- `-I-`   \n  Marks the beginning of the system include path. When an included\n  file is given with angle brackets, (as in `#include <stdio.h>`),\n  one only searches directories specified by the `-I` options that\n  follow `-I-`. Therefore all these include directives are ignored\n  unless one uses option `-I-` followed by one or more option `-I`.\n\n- `-dM`   \n  Instead of producing the preprocessed file,\n  dumps all macros defined at the end of the parse.\n\n- `-Zcppdef`   \n  Run the native preprocessor using command `cpp -dM < dev/null`\n  and copy its predefined symbols. This is useful when using\n  `lcpp` as a full replacement for the standard preprocessor.\n\n- `-Zpass`   \n  This option is enabled by default (use `-Znopass` to disable)\n  and indicates that the output of `lcpp` is going to be\n  reprocessed by a C preprocessor and compiler.\n  This option triggers the following behavior:\n\n  * The preprocessor directives `#pragma` and `#ident`\n    are copied verbatim into the output file.\n  * When the included file cannot be found in the provided\n    search path, the preprocessor directive `#include` is\n    copied into the output file.\n  * Preprocessor directives prefixed with a double `##` are copied\n    verbatim into the output file with a single `#` prefix.  This\n    feature is useful for `#if` directives that depend on symbols\n    defined by unresolved `#include` directives.\n\n- `-std=(c|gnu)(89|99|11)`  \n  This option selects a C dialect.\n  In the context of the preprocessor, this impacts\n  the symbols predefined by `lcpp` and potentially enables\n  GCC extensions of the variadic macro definition syntax.\n  * Symbol `__CPARSER__` is always defined with value <1>.\n  * Symbols `__STDC__` and `__STDC_VERSION__` are either defined by\n    option `-Zcppdef` or take values suitable for the target C\n    dialect.\n  * Symbols `__GNUC__` and `__GNUC_MINOR__` are either defined by\n    option `-Zcppdef` or are defined to values `4` and `2` if the\n    target dialect starts with string `gnu`.\n    \n  This can be further adjusted using the `-D` or `-U` options.\n  The default dialect is `gnu99`.\n  \n\n### Preprocessor extensions\n\nThe `lcpp` preprocessor implements several useful nonstandard features.\nThe main feature are multiline macros. The other features are mostly\nhere because they make multiline macros more useful.\n\n####  String comparison in conditional expressions\n\nThe C standard specifies that the expressions following `#if`\ndirectives are constant expressions of integral type. However this\nprocessor also handles strings. The only valid operations on strings\nare the equality and ordering comparisons. This is quite useful to\nmake special cases for certain values of the parameters of a multiline\nmacro, as shown later.\n\n####  Multiline macros\n\nPreprocessor directives `#defmacro` and `#endmacro` can be used to\ndefine a function-like macro whose body spans several lines. The\n`#defmacro` directive contains the macro name and a mandatory argument\nlist. The body of the macro is composed of all the following lines up\nto the matching `#endmacro`. This offers several benefits:\n\n* The line numbers of the macro-expansion is preserved. This ensures\n  that the compiler produces error messages with meaningful line\n  numbers.\n\n* The multi-line macro can contain preprocessor directives.\n  Conditional directives are very useful in this context.  Note\n  however that preprocessor definitions (with `#define`, `#defmacro`,\n  or `#undef`) nested inside multiline macros are only valid within\n  the macro.\n\n* The standard stringification `#` and token concatenation `##`\n  operators can be used freely in the body of multiline macros.  Note\n  that these operators only work with the parameters of the multiline\n  macros and not with ordinary preprocessor definitions. This is\n  consistent with the standard behavior of these operators in ordinary\n  preprocessor macros.\n\n  Example\n\n```C\n      #defmacro DEFINE_VDOT(TNAME, TYPE)\n        TYPE TNAME##Vector_dot(TYPE *a, TYPE *b, int n)\n        {\n          /* try cblas */\n        #if #TYPE == \"float\"\n          return cblas_sdot(n, a, 1, b, 1);\n        #elif #TYPE == \"double\"\n          return cblas_ddot(n, a, 1, b, 1);\n        #else\n          int i;\n          TYPE s = 0;\n          for(i=0;i<n;i++)\n            s += a[i] * b[i];\n          return s;\n        #endif\n        }\n      #endmacro\n\n      DEFINE_VDOT(Float,float);\n      DEFINE_VDOT(Double,double);\n      DEFINE_VDOT(Int,int);\n```\n\nDetails -- The values of the macro parameters are normally\nmacro-expanded before substituting them into the text of the\nmacro. However this macro-expansion does not happen when the\nsubstitution occurs in the context of a stringification or token\nconcatenation operator.  All this is consistent with the standard. The\nnovelty is that this macro-expansion does not occur either when the\nparameter appears in a nested preprocessor directive or multiline\nmacro.\n\t\nMore details -- The stringification operator only works when the next\nnon-space token is a macro parameter.  This provides a good way to\ndistinguish a nested directive from a stringification operator\nappearing in the beginning of a line.\n\nEven more details -- The standard mandates that the tokens generated\nby a macro-expansion can be combined with the following tokens to\ncompose a new macro invocation. This is not allowed for multiline\nmacros. An error is signaled if the expansion of a multiline macro\ngenerates an incomplete macro argument list.\n\n\n\n####  Negative comma in variadic macros\n\nConsider the following variadic macro\n\n```C\n     #define macro(msg, ...)  printf(msg, __VA_ARGS__)\n```\n\nThe C standard says that it is an error to call this macro with only\none argument. Calling this macro with an empty second argument\n--`macro(msg,)`-- leaves an annoying comma in the expansion\n--`printf(msg,)`-- and causes a compiler syntax error.\n\nThis preprocessor accepts invocations of such a macro with a single\nargument. The value of parameter `__VA_ARGS__` is then a so-called\nnegative comma, meaning that the preceding comma is eliminated when\nthis parameter appears in the macro definition between a comma and a\nclosing parenthesis.\n\n####  Recursive macros\n\nWhen a new invocation of the macro appears in the expansion of a\nmacro, the standard specifies that the preprocessor must rescan the\nexpansion but should not recursively expand the macro.  Although this\nrestriction is both wise and useful, there are rare cases where one\nwould like to use recursive macros.  As an experiment, this recursion\nprevention feature is turned off when one defines a multiline macro\nwith `#defrecursivemacro` instead of `#defmacro`. Note that this might\nprevent the preprocessor from terminating unless the macro eventually\ntakes a conditional branch that does not recursively invoke the macro.\n\n---\n\n## Program `lcdecl`\n\n\n### Synopsis\n\n```sh\n    ldecl [options] inputfile.c [-o outputfile.txt]\n```\n\nPreprocess and parse file `inputfile.c`.\nThe output of a parser is a sequence of Lua data structures\nrepresenting each C definition or declaration encountered in the code.\nProgram `ldecl` prints each of them in two forms. The first form\ndirectly represent the Lua tables composing the data structure. The\nsecond form reconstructs a piece of C code representing the definition\nor declaration of interest.\n\nThis program is mostly useful to people working with the Lua functions\noffered by the `cparser` module because it provides a quick way to inspect\nthe resulting data structures.\n\n\n\n### Options\n\nProgram `lcdecl` accepts all the preprocessing options\ndocumented for program `lcpp`. It also accepts an additional\noption `-T`*typename* and also adds to the meaning of\noptions `-Zpass` and `-std=`*dialect*.\n\n- `-T`*typename*   \n   Similar to `lcpp`, program `lcdecl` only reads the include files that\n   are found along the path specified by the `-I` options. It is\n   generally not desirable to read all include files because they\n   often contain declarations that are not directly useful. This also\n   means that the C parser may not be aware of type definitions found\n   in ignored include files. Although the C syntax is sufficiently\n   unambiguous to allow the parser to guess that an identifier is a\n   type name rather than a variable name, this can lead to confusing\n   error messages. Option `-T`*typename* can then be used to inform\n   the parser than symbol `typename` represents a type and not a\n   constant, a variable, or a function.\n\n- `-Zpass`\n   Unlike `lcpp`, program `lcdecl` processes the input file\n   with option `-Zpass` off by default. Turning it on will\n   just eliminate potentially useful warning messages.\n\n- `-Ztag`\n   This option causes `lcdecl` to treat all structs, unions, and enums\n   as tagged types, possibly using synthetic tags of the form\n   `__anon_XXXXX`. It is assumed that such names are not used anywhere\n   in the parsed program. This is useful for certain code\n   transformation applications.\n\n- `-std=(c|gnu)(89|99|11)`  \n   The dialect selection options also control whether the parser\n   recognizes keywords introduced by later version of the C standard\n   (e.g., `restrict`, `_Bool`, `_Complex`, `_Atomic`, `_Pragma`,\n   `inline`) or by the GCC compiler (e.g., `asm`). Many of these\n   keywords have a double-underline-delimited variant that is\n   recognized in all cases (e.g, `__restrict__`).\n\nExample.\n\nRunning `ldecl` on the following program\n\n```C\nconst int size = (3+2)*2;\nfloat arr[size];\ntypedef struct symtable_s { const char *name; SymVal value; } symtable_t;\nvoid printSymbols(symtable_t *p, int n) { do_something(p,n); }\n```\n\nproduces the following output (with very long lines).\n\n```\n+--------------------------\n| Definition{where=\"test.c:2\",intval=10,type=Qualified{t=Type{n=\"int\"},const=true},name=\"size\",init={..}}\n| const int size = 10\n+--------------------------\n| Definition{where=\"test.c:3\",type=Array{t=Type{n=\"float\"},size=10},name=\"arr\"}\n| float arr[10]\n+--------------------------\n| TypeDef{sclass=\"[typetag]\",where=\"test.c:4\",type=Struct{Pair{Pointer{t=Qualified{t=Type{n=\"char\"},const=true}},\"name\"},Pair{Type{n=\"SymVal\"},\"value\"},n=\"symtable_s\"},name=\"struct symtable_s\"}\n| [typetag] struct symtable_s{const char*name;SymVal value;}\n+--------------------------\n| TypeDef{sclass=\"typedef\",where=\"test.c:4\",type=Type{_def={..},n=\"struct symtable_s\"},name=\"symtable_t\"}\n| typedef struct symtable_s symtable_t\n+--------------------------\n| Definition{where=\"test.c:5\",type=Function{Pair{Pointer{t=Type{_def={..},n=\"symtable_t\"}},\"p\"},Pair{Type{n=\"int\"},\"n\"},t=Type{n=\"void\"}},name=\"printSymbols\",init={..}}\n| void printSymbols(symtable_t*p,int n){..}\n+--------------------------\n```\n\n\n\n---\n\n## Module `cparser`\n\nModule `cparser` exports the following functions:\n\n### Preprocessing function\n\n\n##### `cparser.cpp(filename, outputfile, options)`\n\nProgram `lcpp` is implemented by function `cparser.cpp`.\n\nCalling this function preprocesses file `filename` and writes the\npreprocessed code to the specified output.  The optional argument\n`outputfile` can be a file name or a Lua file descriptor.  When this\nargument is `nil`, the preprocessed code is written to the standard\noutput.  The optional argument `options` is an array of option\nstrings.  All the options documented with program `lcpp` are\nsupported.\n\n##### `cparser.cppTokenIterator(options, lines, prefix)`\n\nCalling this function produces two results:\n* A token iterator function.\n* A macro definition table.\n\nArgument `options` is an array of options.\nAll the options documented for program `lcpp` are supported.\nArgument `lines` is an iterator that returns input lines.\nLua provides many such iterators, including `io.lines(filename)` to\nreturn the lines of the file named `filename` and `filedesc:lines()`\nto return lines from the file descriptor `filedesc`. You can also use\n`string.gmatch(somestring,'[^\\n]+')` to return lines from string\n`somestring`.\n\nEach successive call of the token iterator function describes a token\nof the preprocessed code by returning two strings.  The first string\nrepresent the token text. The second string follows format\n`\"filename:lineno\"` and indicates on which line the token was\nfound. The filename either is the argument `prefix` or is the actual\nname of an included file. When all the tokens have been produced, the\ntoken iterator function returns `nil`.\n\nEach named entry of the macro definition table contains the definition\nof the corresponding preprocessor macros. Function\n`cparser.macroToString` can be used to reconstruct the macro\ndefinition from this information.\n\nExample:\n```Lua\n      ti,macros = cparser.cppTokenIterator(nil, io.lines('test/testmacro.c'), 'testmacro.c')\n      for token,location in ti do\n        print(token, location)\n      end\n      for symbol,_ in pairs(macros) do\n        local s = cparser.macroToString(macros,symbol)\n        if s then print(s) end\n      end\n```\n\n##### `cparser.macroToString(macros,name)`\n\nThis function returns a string representing the definition\nof the preprocessor macro `name` found in macro definition table `macros`.\nIt returns `nil` if no such macro is defined.\nNote that the macro definition table contains named entries that\nare not macro definitions but functions implementing\nmagic symbols such as `__FILE__` or `__LINE__`.\n\n\n\n### Parsing functions\n\n##### `cparser.parse(filename, outputfile, options)`\n\nProgram `lcdecl` is implemented by function `cparser.parse`.\n\nCalling this function preprocesses and parses file `filename`, writing\na trace into the specified file. The optional argument `outputfile`\ncan be a file name or a Lua file descriptor.  When this argument is\n`nil`, the preprocessed code is written to the standard output.  The\noptional argument `options` is an array of option strings.  All the\noptions documented with program `lcdecl` are supported.\n\n\n##### `cparser.declarationIterator(options, lines, prefix)`\n\nCalling this function produces three results:\n* A declaration iterator function.\n* A symbol table.\n* A macro definition table.\n\nArgument `options` is an array of options.\nAll the options documented for program `lcdecl` are supported.\nArgument `lines` is an iterator that returns input lines.\nLua provides many such iterators, including `io.lines(filename)` to\nreturn the lines of the file named `filename` and `filedesc:lines()`\nto return lines from the file descriptor `filedesc`. You can also use\n`string.gmatch(somestring,'[^\\n]+')` to return lines from string\n`somestring`.\n\nEach successive call of the declaration iterator function returns a Lua\ndata structure that represents a declaration, a definition, or certain\npreprocessor events.  The format of these data structures is described\nunder function `cparser.declToString`.\n\nThe symbol table contains the definition of all the C language\nidentifiers defined or declared by the parsed files. Type names are\nrepresented by the `Type{}` data structure documented under function\n`cparser.typeToString`. Constants, variables, and functions are\nrepresented by `Definition{}` or `Declaration{}` data structures\nsimilar to those returned by the declaration iterator.\n\nThe macro definition table contains\nthe definition of the preprocessor macros.\nSee the documentation of function `macroToString` for details.\n\nExample\n\n```Lua\n      di = cparser.declarationIterator(nil, io.lines('tests/testmacro.c'), 'testmacro.c')\n      for decl in di do print(decl) print(\">>\", cparser.declToString(decl)) end\n```\n\n\n##### `cparser.typeToString(ty,nam)`\n\nThis function produces a string suitable for\ndeclaring a variable `nam` with type `ty` in a C program.\n\nArgument `ty` is a type data structure.\nArgument `nam` should be a string representing a legal identifier.\nHowever it defaults to `%s` in order to compute a format string\nsuitable for the standard Lua function `string.format`.\n\nModule `cparser` represents each type with a tree whose nodes are Lua\ntables tagged by their `tag` field.  These tables are equipped with a\nconvenient metatable method that prints them compactly by first\ndisplaying the tag then the remaining fields using the standard Lua\nconstruct.\n\nFor instance, the type `const int` is printed as\n```Lua\n      Qualified{t=Type{n=\"int\"},const=true}\n```\nand corresponds to\n```Lua\n      {\n        tag=\"Qualified\",\n        const=true,\n        t= {\n             tag=\"Type\",\n             n = \"int\"\n           }\n      }\n```\n\nThe following tags are used to represent types.\n\n* `Type{n=name}` is used to represent a named type `name`.  There is\n  only one instance of each named type.  Names can be made of multiple\n  keywords, such as `int` or `unsigned long int`, they can also be\n  typedef identifiers, such as `size_t`, or composed names, such as\n  `struct foo` or `enum bar`.  This construct can also contain a field\n  `_def` that points to the definition of the named type if such a\n  definition is known.\n\n* `Qualified{t=basetype,...}` is used to represent a qualified variant\n  of `basetype`. Fields named `const`, `volatile`, or `restrict` are\n  set to true to represent the applicable type qualifiers. When the\n  type appears in function parameters and the base type is a pointer,\n  a field named `static` may contain the guaranteed array size.\n\n* `Pointer{t=basetype}` is used to represent a pointer to an object of\n  type `basetype`. This construct may also contains a field\n  `block=true` to indicate that the pointer refers to a code block (a\n  C extension found in Apple compilers) or a field `ref=true` to\n  indicate a reference type (a C extension inspired by C++.)\n\n* `Array{t=basetype,size=s}` is used to represent an array of object\n  of type `basetype`. The optional field `size` contains the array\n  size when an array size is specified. The size is usually an\n  integer.  However there are situations in which the parser is unable\n  to evaluate the size, for instance because it relies on the C\n  keyword `sizeof(x)`.  In such cases, field `size` is a string\n  containing a C expression for the size.\n\n* `Struct{}` and `Union{}` are used to represent the corresponding C\n  types. The optional field `n` contains the structure tag. Each entry\n  is represented by a `Pair{type,name}` construct located at\n  successive integer indices. This means that the type of the third entry\n  of structure type `ty` can be accessed as `ty[3][1]` and the\n  corresponding name is `ty[3][2]`.  In the case of `Struct{}` tables,\n  the pairs optionally contain a field `bitfield` to indicate a\n  bitfield size for the structure entry.  Field `bitfield` usually\n  contains a small integer but can also contain a string representing\n  a C expression (just like field `size` in the `Array{}` construct.)\n  \n* `Enum{}` is used to represent an enumerated type. The optional\n  field `n` may contain the enumeration tag name. The enumeration\n  constants are reprsented as `Pair{name,value}` located at\n  successive integer indices. The second pair element is only\n  given when the C code contains an explicit value. It can be an\n  integer or an expression strint (just like field `size` in `Array{}`).\n\n* `Function{t=returntype}` is used to represent functions returning an\n  object of type `returntype`. Field `withoutProto` is set to `true`\n  when the function does not provide a prototype.  Otherwise the\n  arguments are described by `Pair{type,name}` located as integer\n  indices. The prototype of variadic functions end with a\n  `Pair{ellipsis=true}` to represent the `...` argument.\n\nThe `Qualified{}`, `Function{}`, `Struct{}`, `Union{}`, and `Enum{}`\ntables may additionally have a field `attr` whose contents represents\nattribute information, such as C11 attributes `[[...]]`, MSVC-style\nattributes `__declspec(...)` or GNU attributes `__attribute__(...)`.\nThis is representing by an array containing all the attribute tokens\n(on odd indices) and their locations (on even indices).\n\n\n##### `cparser.stringToType(s)`\n\nParses string `s` as an abstract type name or a variable declaration\nand returns the type object and possibly the variable name.  This\nfunction returns `nil` when the string cannot be interpreted as a type\nor a declaration, or when the declaration specifies a storage class.\n\nExample\n\n```Lua\n      > return cparser.stringToType(\"int(*)(const char*)\")\n      Pointer{t=Function{Pair{Pointer{t=Qualified{const=true,t=Type{n=\"char\"}}}},t=Type{n=\"int\"}}}\tnil\n```      \n\n\n\n##### `cparser.declToString(decl)`\n\nThis function produces a string that describes the data structures\nreturned by the declaration iterator.  There are in fact three kinds\nof data structures.  All these structures have very similar fields.\nIn particular, field `where` always contains the location of the\ndefinition or declaration.\n\n* `TypeDef{name=n,sclass=s,type=ty}` represents a type definition.\n  This construct is produced in two different situations.  When the C\n  program contains a `typedef` keyword, field `sclass` contains the\n  string `\"typedef\"`, field `name` contains the new type name, and\n  field `type` contains the type description.  When the C program\n  defines a tagged `struct`, `union`, or `enum` type, field `sclass`\n  contains the string `\"[typetag]\"`, field `name` contains the tagged\n  type name (e.g, `\"struct foo\"`), and field `type` contains the type\n  definition (e.g., `Struct{...}`).\n\n* `Declaration{name=n,sclass=s,type=ty,...}` represents the declaration\n  of a variable or function that is defined elsewhere. Field `name`\n  gives the variable or function name. Field `type` gives its type.\n  Field `sclass` can be empty, `\"extern\"`, or `\"static\"`.\n\n* `Definition{name=n,sclass=s,type=ty...}` represents the definition\n  of a constant, a variable, or a function. Field `name` again gives\n  the name, field `type` gives its type, field `sclass` gives its\n  storage class, and field `init` may contain an array of tokens and\n  token locations representing a variable initializer or a function\n  body. Constant definitions may also have a field `intval` contaning\n  the value of an integer constant. This field works like the size of\n  an array: it often contains a small integer but can also contains a\n  string representing the C expression that the parser was unable to\n  evaluate for one reason or another. Enumeration constants are\n  reported with storage class `\"[enum]\"` and with a constant integer\n  type containing an additional field `_enum` that points to the\n  corresponding enumerated type.\n\n* `CppEvent{directive=dir,...}` describes certain preprocessor events\n  that are potentially relevant to a C API. In particular, the\n  definition of an object-like macro `s` with an integer value `v` is\n  reported as `CppEvent{directive=\"define\",name=\"s\",intval=v}` and its\n  deletion as `CppEvent{directive=\"undef\",name=\"s\"}`.  Finally,\n  `CppEvent{directive=\"include\",name=\"fspec\"}` indicates that an\n  include directive was not resolved.\n",
  "source_type": "meta_github_repository",
  "domain": "meta_ai",
  "keywords": [],
  "retrieval_tags": [
    "meta",
    "ai",
    "github",
    "repository",
    "research"
  ]
}