{
  "id": "github_861351393",
  "title": "marimo-prompt-library",
  "description": "Engineer your reusable, customizable, prompt library in Marimo reactive notebooks",
  "url": "https://github.com/disler/marimo-prompt-library",
  "language": "Python",
  "stars": 223,
  "forks": 69,
  "created_at": "2024-09-22T17:01:01Z",
  "updated_at": "2025-09-18T12:23:42Z",
  "topics": [],
  "readme_content": "# Marimo Reactive Notebook Prompt Library\n> Starter codebase to use Marimo reactive notebooks to build a reusable, customizable, Prompt Library.\n>\n> Take this codebase and use it as a starter codebase to build your own personal prompt library.\n>\n> Marimo reactive notebooks & Prompt Library [walkthrough](https://youtu.be/PcLkBkQujMI)\n>\n> Run multiple prompts against multiple models (SLMs & LLMs) [walkthrough](https://youtu.be/VC6QCEXERpU)\n\n<img src=\"./images/multi_slm_llm_prompt_and_model.png\" alt=\"multi llm prompting\" style=\"max-width: 750px;\">\n\n<img src=\"./images/marimo_prompt_library.png\" alt=\"marimo promptlibrary\" style=\"max-width: 750px;\">\n\n## 1. Understand Marimo Notebook\n> This is a simple demo of the Marimo Reactive Notebook\n- Install hyper modern [UV Python Package and Project](https://docs.astral.sh/uv/getting-started/installation/)\n- Install dependencies `uv sync`\n- Install marimo `uv pip install marimo`\n- To Edit, Run `uv run marimo edit marimo_is_awesome_demo.py`\n- To View, Run `uv run marimo run marimo_is_awesome_demo.py`\n- Then use your favorite IDE & AI Coding Assistant to edit the `marimo_is_awesome_demo.py` directly or via the UI.\n\n## 2. Ad-hoc Prompt Notebook\n> Quickly run and test prompts across models\n- 游리 Copy `.env.sample` to `.env` and set your keys (minimally set `OPENAI_API_KEY`)\n    - Add other keys and update the notebook to add support for additional SOTA LLMs\n- 游리 Install Ollama (https://ollama.ai/) and pull the models you want to use\n    - Update the notebook to use Ollama models you have installed\n- To Edit, Run `uv run marimo edit adhoc_prompting.py`\n- To View, Run `uv run marimo run adhoc_prompting.py`\n\n## 3. 救넖잺 Prompt Library Notebook\n> Build, Manage, Reuse, Version, and Iterate on your Prompt Library\n- 游리 Copy `.env.sample` to `.env` and set your keys (minimally set `OPENAI_API_KEY`)\n    - Add other keys and update the notebook to add support for additional SOTA LLMs\n- 游리 Install Ollama (https://ollama.ai/) and pull the models you want to use\n    - Update the notebook to use Ollama models you have installed\n- To Edit, Run `uv run marimo edit prompt_library.py`\n- To View, Run `uv run marimo run prompt_library.py`\n\n## 4. Multi-LLM Prompt\n> Quickly test a single prompt across multiple language models\n- 游리 Ensure your `.env` file is set up with the necessary API keys for the models you want to use\n- 游리 Install Ollama (https://ollama.ai/) and pull the models you want to use\n    - Update the notebook to use Ollama models you have installed\n- To Edit, Run `uv run marimo edit multi_llm_prompting.py`\n- To View, Run `uv run marimo run multi_llm_prompting.py`\n\n## 5. Multi Language Model Ranker\n> Compare and rank multiple language models across various prompts\n- 游리 Ensure your `.env` file is set up with the necessary API keys for the models you want to compare\n- 游리 Install Ollama (https://ollama.ai/) and pull the models you want to use\n    - Update the notebook to use Ollama models you have installed\n- To Edit, Run `uv run marimo edit multi_language_model_ranker.py`\n- To View, Run `uv run marimo run multi_language_model_ranker.py`\n\n## General Usage\n> See the [Marimo Docs](https://docs.marimo.io/index.html) for general usage details\n\n## Personal Prompt Library Use-Cases\n- Ad-hoc prompting\n- Prompt reuse\n- Prompt versioning\n- Interactive prompts\n- Prompt testing & Benchmarking\n- LLM comparison\n- Prompt templating\n- Run a single prompt against multiple LLMs & SLMs\n- Compare multi prompts against multiple LLMs & SLMs\n- Anything you can imagine!\n\n## Advantages of Marimo\n\n### Key Advantages\n> Rapid Prototyping: Seamlessly transition between user and builder mode with `cmd+.` to toggle. Consumer vs Producer. UI vs Code. \n\n> Interactivity: Built-in reactive UI elements enable intuitive data exploration and visualization.\n\n> Reactivity: Cells automatically update when dependencies change, ensuring a smooth and efficient workflow.\n\n> Out of the box: Use sliders, textareas, buttons, images, dataframe GUIs, plotting, and other interactive elements to quickly iterate on ideas.\n\n> It's 'just' Python: Pure Python scripts for easy version control and AI coding.\n\n\n- **Reactive Execution**: Run one cell, and marimo automatically updates all affected cells. This eliminates the need to manually manage notebook state.\n- **Interactive Elements**: Provides reactive UI elements like dataframe GUIs and plots, making data exploration fast and intuitive.\n- **Python-First Design**: Notebooks are pure Python scripts stored as `.py` files. They can be versioned with git, run as scripts, and imported into other Python code.\n- **Reproducible by Default**: Deterministic execution order with no hidden state ensures consistent and reproducible results.\n- **Built for Collaboration**: Git-friendly notebooks where small changes yield small diffs, facilitating collaboration.\n- **Developer-Friendly Features**: Includes GitHub Copilot, autocomplete, hover tooltips, vim keybindings, code formatting, debugging panels, and extensive hotkeys.\n- **Seamless Transition to Production**: Notebooks can be run as scripts or deployed as read-only web apps.\n- **Versatile Use Cases**: Ideal for experimenting with data and models, building internal tools, communicating research, education, and creating interactive dashboards.\n\n### Advantages Over Jupyter Notebooks\n\n- **Reactive Notebook**: Automatically updates dependent cells when code or values change, unlike Jupyter where cells must be manually re-executed.\n- **Pure Python Notebooks**: Stored as `.py` files instead of JSON, making them easier to version control, lint, and integrate with Python tooling.\n- **No Hidden State**: Deleting a cell removes its variables and updates affected cells, reducing errors from stale variables.\n- **Better Git Integration**: Plain Python scripts result in smaller diffs and more manageable version control compared to Jupyter's JSON format.\n- **Import Symbols**: Allows importing symbols from notebooks into other notebooks or Python files.\n- **Enhanced Interactivity**: Built-in reactive UI elements provide a more interactive experience than standard Jupyter widgets.\n- **App Deployment**: Notebooks can be served as web apps or exported to static HTML for easier sharing and deployment.\n- **Advanced Developer Tools**: Features like code formatting, GitHub Copilot integration, and debugging panels enhance the development experience.\n- **Script Execution**: Can be executed as standard Python scripts, facilitating integration into pipelines and scripts without additional tools.\n\n## Resources\n- https://docs.astral.sh/uv/\n- https://docs.marimo.io/index.html\n- https://youtu.be/PcLkBkQujMI\n- https://github.com/BuilderIO/gpt-crawler\n- https://github.com/simonw/llm\n- https://ollama.com/\n- https://ai.meta.com/blog/llama-3-2-connect-2024-vision-edge-mobile-devices/\n- https://qwenlm.github.io/",
  "source_type": "github_repository",
  "domain": "software_development",
  "keywords": [
    "react"
  ],
  "retrieval_tags": [
    "github",
    "repository",
    "code",
    "development"
  ]
}