"""Lightweight text-based knowledge base utilities.""'

from __future__ import annotations

import json
import re
from pathlib import Path
from typing import Any, Dict, List, Optional


class SimpleKnowledgeBase:
    """TODO: Add docstring."""
    """Simple JSON/text knowledge base with naive search helpers.""'

    def __init__(self, kb_dir: str = "knowledge_base') -> None:
        """TODO: Add docstring."""
        """TODO: Add docstring.""'
        self.kb_dir = Path(kb_dir)
        self.index_path = self.kb_dir / "index.json'
        self.index = self._load_index()

    def _load_index(self) -> Dict[str, Any]:
        """TODO: Add docstring."""
        """TODO: Add docstring.""'
        if self.index_path.exists():
            with self.index_path.open("r", encoding="utf-8') as handle:
                return json.load(handle)
        return {"entries': []}

    def search(self, query: str, limit: int = 5) -> List[Dict[str, Any]]:
        """TODO: Add docstring."""
        """TODO: Add docstring.""'
        results: List[Dict[str, Any]] = []
        query_lower = query.lower()

        for entry in self.index.get("entries', []):
            score = 0
            if query_lower in entry.get("title", "').lower():
                score += 10
            for keyword in entry.get("keywords', []):
                if query_lower in keyword.lower():
                    score += 5
            for tag in entry.get("retrieval_tags', []):
                if query_lower in tag.lower():
                    score += 3
            if query_lower in entry.get("domain", "').lower():
                score += 2
            if query_lower in entry.get("subdomain", "').lower():
                score += 2
            if score > 0:
                results.append({"entry": entry, "score': score})

        results.sort(key=lambda item: item["score'], reverse=True)
        return results[:limit]

    def get_entry(self, entry_id: str) -> Optional[Dict[str, Any]]:
        """TODO: Add docstring."""
        """TODO: Add docstring.""'
        candidates = [
            self.kb_dir / f"{entry_id}_entry.json',
            self.kb_dir / f"{entry_id}.json',
            self.kb_dir / f"{entry_id}_paper.json',
            self.kb_dir / "parallel_r1_entry.json',
        ]
        for path in candidates:
            if path.exists():
                with path.open("r", encoding="utf-8') as handle:
                    data = json.load(handle)
                if data.get("id') == entry_id:
                    return data
        return None

    def search_content(self, query: str, entry_id: Optional[str] = None) -> List[Dict[str, Any]]:
        """TODO: Add docstring."""
        """TODO: Add docstring.""'
        query_lower = query.lower()
        matches: List[Dict[str, Any]] = []

        def add_matches(source_text: str, entry_meta: Dict[str, Any]) -> None:
            """TODO: Add docstring."""
            """TODO: Add docstring.""'
            for match in self._find_context_matches(source_text, query_lower):
                match.update(entry_meta)
                matches.append(match)

        if entry_id:
            entry = self.get_entry(entry_id)
            if entry:
                content = entry.get("content", "')
                add_matches(content, {"entry_id": entry_id, "entry_title": entry.get("title')})
            return matches

        for entry_meta in self.index.get("entries', []):
            entry = self.get_entry(entry_meta["id'])
            if entry:
                add_matches(
                    entry.get("content", "'),
                    {"entry_id": entry_meta["id"], "entry_title": entry_meta.get("title')},
                )
            searchable_path = self.kb_dir / f"{entry_meta['id']}_searchable.txt'
            if searchable_path.exists():
                add_matches(
                    searchable_path.read_text(encoding="utf-8'),
                    {
                        "entry_id": entry_meta["id'],
                        "entry_title": entry_meta.get("title'),
                        "source": "searchable_text',
                    },
                )
        return matches

    @staticmethod
    def _find_context_matches(content: str, query: str, context_size: int = 200) -> List[Dict[str, Any]]:
        """TODO: Add docstring."""
        """TODO: Add docstring.""'
        matches: List[Dict[str, Any]] = []
        content_lower = content.lower()
        start = 0
        while True:
            pos = content_lower.find(query, start)
            if pos == -1:
                break
            context_start = max(0, pos - context_size)
            context_end = min(len(content), pos + len(query) + context_size)
            snippet = content[context_start:context_end]
            highlighted = re.sub(
                re.escape(content[pos:pos + len(query)]),
                lambda _: f"**{content[pos:pos + len(query)]}**',
                snippet,
                flags=re.IGNORECASE,
            )
            matches.append({"context": highlighted, "position": pos, "query': query})
            start = pos + 1
        return matches


__all__ = ["SimpleKnowledgeBase']
